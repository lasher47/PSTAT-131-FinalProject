---
title: "Predicting the Winner of a League of Legends game"
author: "William Long"
date: "Fall 2022"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    code_folding: hide

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

The goal of this project is to generate a machine learning model that can predict the eventual winner of a ranked game of League of Legends using data from the first 10 minutes of that game.

### What is League of Legends?

League of Legends(LoL) is a MOBA(Mobile Online Battle Arena) game created by Riot Games where two teams of 5 champions each versus each other in a tower defense-esque map. The game
revolves heavily around strategic resource generation and control of those resources to make your team’s champions stronger and more capable of destroying the enemy team’s base. A team wins by destroying the other team's nexus(the core base structure) first. 

### Why this model might be useful

In League of Legends, once your team gets stronger from early resources, it becomes even easier for your team to fight for more resources. As such, early game advantages often snowball exponentially into an eventual victory for the leading team. This model will attempt to predict the eventual winner of a game given this early game data. Hopefully this will give other players insight as to when its statistically worth it to surrender after a bad early game and on what resources to prioritize in the early game.



### Loading Packages and Raw Data
```{r packages}
library(tidymodels)  #Tidymodels and tidyverse for the core modeling framework
library(tidyverse)
library(dplyr) #Basic R functions
library(janitor)   #Cleaning data
library(yardstick)   #Model metrics
library(ggplot2)   #Graphs and visuals
library(vip)     #Variable importance
library(corrr)   #Correlation
library(arsenal)

set.seed(477)

```

The data that we will be using for this project is a Kaggle dataset(https://www.kaggle.com/datasets/bobbyscience/league-of-legends-diamond-ranked-games-10-min) containing early game data from high elo(D1 - Masters) ranked games from the EUW server. The dataset encompasses approximately 10,000 games with variables tracking statistics from both teams snapshotted at the 10:00 minute mark. Descriptions of every variable are available in the codebook in this project repository. 


```{r read}
#Reading in raw csv file
league <- read.csv("data/raw/high_diamond_ranked_10min.csv")

```



## Pre-Processing and EDA

```{r missing}
sum(is.na(league))
```

No missing data here because this was all sourced from Riot Games' official API which only records completed games. 

```{r missing}
#Summing up all the times the Blue Team wins over 9879 ranked games
sum(league$blueWins)

```

Since there is no missing data in this dataset, we can conclude that the sample winrate for blue team is 4930/9879 = 0.499. This is actually lower than blue side winrate for most competitive professional leagues because blue side has easier access to neutral objectives(dragons, heralds, and Baron Nashor), first champion pick priority, and a slightly better camera angle. Having our sample winrate be almost exactly 50% makes it easier for our metrics to properly evaluate the performance of our model.   

### Converting some variables into categorical

All of the variables in our raw dataset are numeric by default, but some of them make more sense to represent as factor variables. "blueWins" is an obvious one to change, but some others such as "blueDragons" ,which tracks how many dragons the Blue team has slain, makes more sense to treat as a factor variable because it is only possible to kill at most 1 dragon before 10:00 of game time. 

```{r}

league_clean <- league

#Blue team categorical variables
league_clean$blueWins <- as.factor(league_clean$blueWins)
league_clean$blueDragons <- as.factor(league_clean$blueDragons)
league_clean$blueHeralds <- as.factor(league_clean$blueHeralds)
league_clean$blueFirstBlood <- as.factor(league_clean$blueFirstBlood)

#Red team categorical variables
league_clean$redDragons <- as.factor(league_clean$redDragons)
league_clean$redHeralds <- as.factor(league_clean$redHeralds)

```



### Cleaning Data

On first glance, we can see that some variables in this dataset are actually redundant because they convey information from both teams implicitly. For example, blueGoldDiff and redGoldDiff both represent the difference in gold at 10 min., but just opposite signs because gold difference is a zero sum statistic. The code chunk below gets rid of redundant variables by either combining them into one variable or retaining only the blue side version. We will also eliminate variables that have 100% correlation with another variable as those variables will not provide any extra information for our model. 


```{r redundant}

league_clean <- league_clean %>%
  select(-c(redFirstBlood, redExperienceDiff, redGoldDiff)) #Redundant difference variables

league_clean <- league_clean %>%
  select(-c(blueEliteMonsters, redEliteMonsters))
# Both "EliteMonsters" variables are also just the sum of heralds and dragons and can be dropped

league_clean <- league_clean %>%
  select(-c(blueCSPerMin, redCSPerMin, blueGoldPerMin, redGoldPerMin))
#Dropping the "PerMin" variables as those are just derived from the variables that represent the total/10 minutes. 

cor.test(league_clean$blueKills, league_clean$redDeaths)  
cor.test(league_clean$blueDeaths, league_clean$redKills)   #These 4 variables are all directly correlated with each other. Makes sense intuitively because a kill for one team would equal a death for the other team. We will drop the red ones below.

league_clean <- league_clean %>%
  select(-c(redDeaths, redKills))

#From my previous knowledge of the game, I know that total minion kills and jungle minion kills are really just resources to farm for gold and experience. As such, their impact on the game is already reflected in those other stats.

league_clean <- league_clean %>%
  select(-c(blueTotalMinionsKilled, blueTotalJungleMinionsKilled, redTotalMinionsKilled, redTotalJungleMinionsKilled))
  
```

### Correlations between variables

```{r corr}
#Testing correlations between numeric variables
cor_league <- league_clean %>%
  select_if(is.numeric) %>%
  select(-c(gameId)) %>%
  correlate() %>%
  stretch() %>%
  ggplot(aes(x, y, fill = r)) +
  geom_tile() +
  geom_text(aes(label = as.character(fashion(r))))

cor_league
```



Creating a few more variables that track the difference in resources between teams.

```{r diff}
league_clean <- league_clean %>%
  mutate(blueTotalMinionsDiff = blueTotalMinionsKilled - redTotalMinionsKilled) %>%
  mutate(blueWardsPlacedDiff = blueWardsPlaced - redWardsPlaced) %>%
  mutate(blueWardsDestroyedDiff = blueWardsDestroyed - redWardsDestroyed) %>%
  mutate(blueKillsDiff = blueKills - redKills) %>%
  mutate()

```

Many variables in the dataset

```{r}

```

